#ifndef GENERATED_CONSTANTS_H
#define GENERATED_CONSTANTS_H
// Do not edit this file.  This file is automatically generated
//  from objsizes.cc

#include "malloc_internal.h"
#include <stdlib.h>
#include <stdint.h>
#include <sys/types.h>
// For chunks containing small objects, we reserve the first
// several pages for bitmaps and linked lists.
//   There's a per_page struct containing 2 pointers and a
//   bitmap, and there are 512 of those.
// As a result, there is no overhead in each page, but there is
// overhead per chunk, which affects the large object sizes.

// We obtain hugepages from the operating system via mmap(2).
// By `hugepage', I mean only mmapped pages.
// By `page', I mean only a page inside a hugepage.
// Each hugepage has a bin number.
// We use a static array to keep track of the bin of each a hugepage.
//  Bins [0..first_huge_bin_number) give the size of an object.
//  Larger bin numbers B indicate the object size, coded as
//     malloc_usable_size(object) = page_size*(bin_of(object)-first_huge_bin_number;
static const struct static_bin_s { uint32_t object_size, folio_size; uint16_t objects_per_folio, folios_per_chunk;  uint8_t object_division_shift_magic, folio_division_shift_magic; uint64_t object_division_multiply_magic, folio_division_multiply_magic;} static_bin_info[] __attribute__((unused)) = {
// The first class of small objects try to get a maximum of 25% internal fragmentation by having sizes of the form c<<k where c is 4, 5, 6 or 7.
// We stop at when we have 4 cachelines, so that the ones that happen to be multiples of cache lines are either a power of two or odd.
//   objsize foliosize objects_per_folio  multiply_division_magic shift_division_magic   bin   wastage
 {       8,    4096, 512, 512,  3, 12,          1lu,          1lu},  //   0      0
 {      10,    4096, 409, 512, 36, 12, 6871947674lu,          1lu},  //   1      6
 {      12,    4096, 341, 512, 36, 12, 5726623062lu,          1lu},  //   2      4
 {      14,    4096, 292, 512, 36, 12, 4908534053lu,          1lu},  //   3      8
 {      16,    4096, 256, 512,  4, 12,          1lu,          1lu},  //   4      0
 {      20,    4096, 204, 512, 37, 12, 6871947674lu,          1lu},  //   5     16
 {      24,    4096, 170, 512, 37, 12, 5726623062lu,          1lu},  //   6     16
 {      28,    4096, 146, 512, 37, 12, 4908534053lu,          1lu},  //   7      8
 {      32,    4096, 128, 512,  5, 12,          1lu,          1lu},  //   8      0
 {      40,    4096, 102, 512, 38, 12, 6871947674lu,          1lu},  //   9     16
 {      48,    4096,  85, 512, 38, 12, 5726623062lu,          1lu},  //  10     16
 {      56,    4096,  73, 512, 38, 12, 4908534053lu,          1lu},  //  11      8
 {      64,    4096,  64, 512,  6, 12,          1lu,          1lu},  //  12      0
 {      80,    4096,  51, 512, 39, 12, 6871947674lu,          1lu},  //  13     16
 {      96,    4096,  42, 512, 39, 12, 5726623062lu,          1lu},  //  14     64
 {     112,    4096,  36, 512, 39, 12, 4908534053lu,          1lu},  //  15     64
 {     128,    4096,  32, 512,  7, 12,          1lu,          1lu},  //  16      0
 {     160,    4096,  25, 512, 40, 12, 6871947674lu,          1lu},  //  17     96
 {     192,    4096,  21, 512, 40, 12, 5726623062lu,          1lu},  //  18     64
 {     224,    4096,  18, 512, 40, 12, 4908534053lu,          1lu},  //  19     64
 {     256,    4096,  16, 512,  8, 12,          1lu,          1lu},  //  20      0
// Class 2 small objects are prime multiples of a cache line.
// The folio size is such that the number of 4K pages equals the
// number of cache lines in the object.  Namely, the folio size is 64 times
// the object size.  The small_chunk_header fits into 8 pages.
 {     320,   20480,  64, 102, 41, 47, 6871947674lu, 6871947674lu},  //  21     0.784 ( 5 cache lines, 100 folios/chunk, at least 16448 bytes used/folio)
 {     448,   28672,  64,  73, 41, 47, 4908534053lu, 4908534053lu},  //  22     0.705 ( 7 cache lines, 72 folios/chunk, at least 20544 bytes used/folio)
 {     512,    4096,   8, 512,  9, 12,          1lu,          1lu},  //  23     0.863 ( 8 cache lines, 504 folios/chunk, at least 3592 bytes used/folio)
 {     704,   45056,  64,  46, 42, 48, 6247225158lu, 6247225158lu},  //  24     0.617 (11 cache lines, 45 folios/chunk, at least 28736 bytes used/folio)
 {     832,   53248,  64,  39, 42, 48, 5286113596lu, 5286113596lu},  //  25     0.818 (13 cache lines, 38 folios/chunk, at least 45120 bytes used/folio)
 {    1024,    4096,   4, 512, 10, 12,          1lu,          1lu},  //  26     0.801 (16 cache lines, 504 folios/chunk, at least 3332 bytes used/folio)
 {    1088,   69632,  64,  30, 43, 49, 8084644322lu, 8084644322lu},  //  27     0.737 (17 cache lines, 29 folios/chunk, at least 53312 bytes used/folio)
 {    1472,   94208,  64,  22, 43, 49, 5975606673lu, 5975606673lu},  //  28     0.698 (23 cache lines, 21 folios/chunk, at least 69696 bytes used/folio)
 {    1984,  126976,  64,  16, 43, 49, 4433514629lu, 4433514629lu},  //  29     0.719 (31 cache lines, 16 folios/chunk, at least 94272 bytes used/folio)
 {    2048,    4096,   2, 512, 11, 12,          1lu,          1lu},  //  30     0.954 (32 cache lines, 504 folios/chunk, at least 3970 bytes used/folio)
 {    2752,  176128,  64,  11, 44, 50, 6392509464lu, 6392509464lu},  //  31     0.666 (43 cache lines, 11 folios/chunk, at least 127040 bytes used/folio)
 {    3904,  249856,  64,   8, 44, 50, 4506195196lu, 4506195196lu},  //  32     0.672 (61 cache lines, 8 folios/chunk, at least 176192 bytes used/folio)
 {    4096,    4096,   1, 512, 12, 12,          1lu,          1lu},  //  33     0.938 (64 cache lines, 504 folios/chunk, at least 3905 bytes used/folio)
 {    5312,  339968,  64,   6, 45, 51, 6623564023lu, 6623564023lu},  //  34     0.715 (83 cache lines, 6 folios/chunk, at least 249920 bytes used/folio)
 {    7232,  462848,  64,   4, 45, 51, 4865095699lu, 4865095699lu},  //  35     0.649 (113 cache lines, 4 folios/chunk, at least 340032 bytes used/folio)
 {    8192,    8192,   1, 256, 13, 13,          1lu,          1lu},  //  36     0.869 (128 cache lines, 252 folios/chunk, at least 7233 bytes used/folio)
 {   10048,  643072,  64,   3, 46, 52, 7003258776lu, 7003258776lu},  //  37     0.662 (157 cache lines, 3 folios/chunk, at least 462912 bytes used/folio)
 {   14272,  913408,  64,   2, 46, 52, 4930545417lu, 4930545417lu},  //  38     0.613 (223 cache lines, 2 folios/chunk, at least 643136 bytes used/folio)
// large objects (page allocated):
//  So that we can return an accurate malloc_usable_size(), we maintain (in the first page of each largepage chunk) information about each object (large_object_list_cell)
//   For unallocated objects we maintain a next pointer to the next large_object_list_cell for an free object of the same size.
//   For allocated objects, we maintain the footprint.
//  This extra information always fits within one page.
//  This introduces fragmentation.  This fragmentation doesn't matter much since it will be purged. For sizes up to 1<<17 we waste the last potential object.
//   for the larger stuff, we reduce the size of the object slightly which introduces some other fragmentation
 {   16384,   16384,   1, 128, 14, 14,          1lu,          1lu},  //  39 
 {   32768,   32768,   1,  64, 15, 15,          1lu,          1lu},  //  40 
 {   65536,   65536,   1,  32, 16, 16,          1lu,          1lu},  //  41 
 {  131072,  131072,   1,  16, 17, 17,          1lu,          1lu},  //  42 
 {  258048,  258048,   1,   8, 50, 50, 4363141381lu, 4363141381lu},  //  43  (reserve a page for the list of sizes)
 {  520192,  520192,   1,   4, 51, 51, 4328785937lu, 4328785937lu},  //  44  (reserve a page for the list of sizes)
 { 1044480, 1044480,   1,   2, 52, 52, 4311810306lu, 4311810306lu},  //  45  (reserve a page for the list of sizes)
// huge objects (chunk allocated) start  at this size.
 { 2097152, 2097152,   1,   1, 21, 21,          1lu,          1lu},  //  46
};
static const uint64_t offset_of_first_object_in_large_chunk = 4096;
static const size_t largest_large         = 1044480;
static const binnumber_t first_large_bin_number = 39;
static const binnumber_t first_huge_bin_number   = 46;
struct per_folio; // Forward decl needed here.
struct dynamic_small_bin_info {
  union {
    struct {
      per_folio *b0[513];
      per_folio *b1[410];
      per_folio *b2[342];
      per_folio *b3[293];
      per_folio *b4[257];
      per_folio *b5[205];
      per_folio *b6[171];
      per_folio *b7[147];
      per_folio *b8[129];
      per_folio *b9[103];
      per_folio *b10[86];
      per_folio *b11[74];
      per_folio *b12[65];
      per_folio *b13[52];
      per_folio *b14[43];
      per_folio *b15[37];
      per_folio *b16[33];
      per_folio *b17[26];
      per_folio *b18[22];
      per_folio *b19[19];
      per_folio *b20[17];
      per_folio *b21[65];
      per_folio *b22[65];
      per_folio *b23[9];
      per_folio *b24[65];
      per_folio *b25[65];
      per_folio *b26[5];
      per_folio *b27[65];
      per_folio *b28[65];
      per_folio *b29[65];
      per_folio *b30[3];
      per_folio *b31[65];
      per_folio *b32[65];
      per_folio *b33[2];
      per_folio *b34[65];
      per_folio *b35[65];
      per_folio *b36[2];
      per_folio *b37[65];
      per_folio *b38[65];
    };
    per_folio *b[3910];
  };
};
// dynamic_small_bin_offset is declared const even though one implementation looks in an array.  The array is a const
static uint32_t dynamic_small_bin_offset(binnumber_t bin) __attribute((const)) __attribute__((unused)) __attribute__((warn_unused_result));
static uint32_t dynamic_small_bin_offset(binnumber_t bin) {
  if (0) {
    switch(bin) {
      case 0: return 0;
      case 1: return 513;
      case 2: return 923;
      case 3: return 1265;
      case 4: return 1558;
      case 5: return 1815;
      case 6: return 2020;
      case 7: return 2191;
      case 8: return 2338;
      case 9: return 2467;
      case 10: return 2570;
      case 11: return 2656;
      case 12: return 2730;
      case 13: return 2795;
      case 14: return 2847;
      case 15: return 2890;
      case 16: return 2927;
      case 17: return 2960;
      case 18: return 2986;
      case 19: return 3008;
      case 20: return 3027;
      case 21: return 3044;
      case 22: return 3109;
      case 23: return 3174;
      case 24: return 3183;
      case 25: return 3248;
      case 26: return 3313;
      case 27: return 3318;
      case 28: return 3383;
      case 29: return 3448;
      case 30: return 3513;
      case 31: return 3516;
      case 32: return 3581;
      case 33: return 3646;
      case 34: return 3648;
      case 35: return 3713;
      case 36: return 3778;
      case 37: return 3780;
      case 38: return 3845;
    }
    abort(); // cannot get here.
  } else {
    const static int offs[]={0, 513, 923, 1265, 1558, 1815, 2020, 2191, 2338, 2467, 2570, 2656, 2730, 2795, 2847, 2890, 2927, 2960, 2986, 3008, 3027, 3044, 3109, 3174, 3183, 3248, 3313, 3318, 3383, 3448, 3513, 3516, 3581, 3646, 3648, 3713, 3778, 3780, 3845};
    return offs[bin];
  }
}
static binnumber_t size_2_bin(size_t size) __attribute((unused)) __attribute((const));
static binnumber_t size_2_bin(size_t size) {
  if (size <= 8) return 0;
  if (size <= 10) return 1;
  if (size <= 12) return 2;
  if (size <= 14) return 3;
  if (size <= 16) return 4;
  if (size <= 20) return 5;
  if (size <= 24) return 6;
  if (size <= 28) return 7;
  if (size <= 32) return 8;
  if (size <= 40) return 9;
  if (size <= 48) return 10;
  if (size <= 56) return 11;
  if (size <= 64) return 12;
  if (size <= 80) return 13;
  if (size <= 96) return 14;
  if (size <= 112) return 15;
  if (size <= 128) return 16;
  if (size <= 160) return 17;
  if (size <= 192) return 18;
  if (size <= 224) return 19;
  if (size <= 256) return 20;
  if (size <= 320) return 21;
  if (size <= 448) return 22;
  if (size <= 512) return 23;
  if (size <= 704) return 24;
  if (size <= 832) return 25;
  if (size <= 1024) return 26;
  if (size <= 1088) return 27;
  if (size <= 1472) return 28;
  if (size <= 1984) return 29;
  if (size <= 2048) return 30;
  if (size <= 2752) return 31;
  if (size <= 3904) return 32;
  if (size <= 4096) return 33;
  if (size <= 5312) return 34;
  if (size <= 7232) return 35;
  if (size <= 8192) return 36;
  if (size <= 10048) return 37;
  if (size <= 14272) return 38;
  if (size <= 16384) return 39;
  if (size <= 32768) return 40;
  if (size <= 65536) return 41;
  if (size <= 131072) return 42;
  if (size <= 258048) return 43;
  if (size <= 520192) return 44;
  if (size <= 1044480) return 45;
  return 45 + ceil(size-1044480, 4096);
}
static size_t bin_2_size(binnumber_t bin) __attribute((unused)) __attribute((const));
static size_t bin_2_size(binnumber_t bin) {
  if (bin == 0) return 8;
  if (bin == 1) return 10;
  if (bin == 2) return 12;
  if (bin == 3) return 14;
  if (bin == 4) return 16;
  if (bin == 5) return 20;
  if (bin == 6) return 24;
  if (bin == 7) return 28;
  if (bin == 8) return 32;
  if (bin == 9) return 40;
  if (bin == 10) return 48;
  if (bin == 11) return 56;
  if (bin == 12) return 64;
  if (bin == 13) return 80;
  if (bin == 14) return 96;
  if (bin == 15) return 112;
  if (bin == 16) return 128;
  if (bin == 17) return 160;
  if (bin == 18) return 192;
  if (bin == 19) return 224;
  if (bin == 20) return 256;
  if (bin == 21) return 320;
  if (bin == 22) return 448;
  if (bin == 23) return 512;
  if (bin == 24) return 704;
  if (bin == 25) return 832;
  if (bin == 26) return 1024;
  if (bin == 27) return 1088;
  if (bin == 28) return 1472;
  if (bin == 29) return 1984;
  if (bin == 30) return 2048;
  if (bin == 31) return 2752;
  if (bin == 32) return 3904;
  if (bin == 33) return 4096;
  if (bin == 34) return 5312;
  if (bin == 35) return 7232;
  if (bin == 36) return 8192;
  if (bin == 37) return 10048;
  if (bin == 38) return 14272;
  if (bin == 39) return 16384;
  if (bin == 40) return 32768;
  if (bin == 41) return 65536;
  if (bin == 42) return 131072;
  if (bin == 43) return 258048;
  if (bin == 44) return 520192;
  if (bin == 45) return 1044480;
  return (bin-45)*pagesize + 1044480;
}

static inline uint32_t divide_offset_by_objsize(uint32_t offset, binnumber_t bin) {
  return (offset * static_bin_info[bin].object_division_multiply_magic) >> static_bin_info[bin].object_division_shift_magic;
}

static inline uint32_t divide_offset_by_foliosize(uint32_t offset, binnumber_t bin) {
  return (offset * static_bin_info[bin].folio_division_multiply_magic) >> static_bin_info[bin].folio_division_shift_magic;
}

#endif
