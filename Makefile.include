SRC = $(ROOT)/src
BLD = $(ROOT)/$(BUILD)
TST = $(ROOT)/tests
LIB = $(BLD)/lib

ifdef NO_RTM
RMTFLAGS = 
else
RTMFLAGS = -mrtm
endif

C_CXX_FLAGS = -W -Wall -Werror $(OPTFLAGS) -ggdb -pthread -fPIC $(RTMFLAGS) $(COVERAGE)
CXXFLAGS = $(C_CXX_FLAGS) -std=c++11
CFLAGS = $(C_CXX_FLAGS) -std=c11
CPPFLAGS += $(STATS) $(LOGCHECK) $(TESTING) -I$(BLD)

LIBOBJECTS = malloc makechunk rng huge_malloc large_malloc small_malloc cache bassert footprint stats futex_mutex generated_constants
default: tests
.PHONY: default

#lib: $(LIB)/libsupermalloc.so
#.PHONY: lib

TESTS = aligned_alloc calloc posix_memalign $(UNITTESTS) test-malloc_test new-malloc-test
TESTS_IN_DIR = $(patsubst %, $(BLD)/%, $(TESTS))

ifeq ($LINKMODE,static)
 IMPLEMENTATION_FILES = $(patsubst %,$(BLD)/%.o, $(LIBOBJECTS))
else
 IMPLEMENTATION_FILES = $(LIB)/libsupermalloc.so
 LDFLAGS += -L$(LIB) -Wl,-rpath,$(LIB)
endif

$(TESTS_IN_DIR): $(IMPLEMENTATION_FILES)
tests: $(TESTS_IN_DIR)

check: $(patsubst %, $(BLD)/%.check, $(TESTS)) \
 check-test-malloc_test-w1 \
 check-test-malloc_test-w2 \
 check-test-malloc_test-w1-s4096 \
 check-test-malloc_test-w1-s-1
.PHONY: check %.check \
 check-test-malloc_test-w1 \
 check-test-malloc_test-w2 \
 check-test-malloc_test-w1-s4096 \
 check-test-malloc_test-w1-s-1

%.check: %
	SUPERMALLOC_THREADCACHE=1 ./$<
	SUPERMALLOC_THREADCACHE=0 ./$<

check-test-malloc_test-w1: $(BLD)/test-malloc_test
	SUPERMALLOC_THREADCACHE=0 $< -w1
	SUPERMALLOC_THREADCACHE=1 $< -w1
check-test-malloc_test-w2: $(BLD)/test-malloc_test
	SUPERMALLOC_THREADCACHE=0 $< -w2
	SUPERMALLOC_THREADCACHE=1 $< -w2
check-test-malloc_test-w1-s4096: $(BLD)/test-malloc_test
	SUPERMALLOC_THREADCACHE=0 $< -w1 -s 4096
	SUPERMALLOC_THREADCACHE=0 $< -w1 -s 4096
check-test-malloc_test-w1-s-1: $(BLD)/test-malloc_test
	SUPERMALLOC_THREADCACHE=0 $< -w1 -s -1
	SUPERMALLOC_THREADCACHE=0 $< -w1 -s -1

OFILES = $(patsubst %, $(BLD)/%.o, $(LIBOBJECTS))
PTHREAD_OFILES = $(patsubst %, $(BLD)/%_pthread.o, $(LIBOBJECTS))

$(LIB):
	mkdir -p $(LIB)
$(LIB)/libsupermalloc.so: $(OFILES) | $(LIB)
	mkdir -p $(LIB)
	$(CXX) $(CXXFLAGS) $^ -shared -o $@
$(LIB)/libsupermalloc_pthread.so: $(PTHREAD_OFILES) | $(LIB)
	mkdir -p $(LIB)
	$(CXX) $(CXXFLAGS) $^ -shared -o $@

$(BLD)/supermalloc.a: $(OFILES)
	ar cr $(BLD)/supermalloc.a $(OFILES)
$(BLD)/%.o: $(SRC)/%.cc
	$(CXX) $(CXXFLAGS) $(CPPFLAGS) -c $< -o $@

$(BLD)/%_pthread.o: $(SRC)/%.cc
	$(CXX) $(CXXFLAGS) $(CPPFLAGS) -DUSE_PTHREAD_MUTEXES -c $< -o $@
$(BLD)/generated_constants_pthread.o: $(BLD)/generated_constants.cc
	$(CXX) $(CXXFLAGS) $(CPPFLAGS) -DUSE_PTHREAD_MUTEXES -c $< -o $@

$(BLD)/%.o: CPPFLAGS += -I$(SRC) 
$(BLD)/%.o: $(TST)/%.c
	$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@
$(BLD)/%: $(BLD)/%.o
	$(CXX) $(CXXFLAGS) $< $(LDFLAGS) $(IMPLEMENTATION_FILES) -o $@

$(PTHREAD_OFILES) $(OFILES): $(wildcard $(SRC)/*.h) $(BLD)/generated_constants.h

# The rule below with a pattern is preferable to the one commented out below because the commented out one will cause ./objsizes to be run twice (which is wrong and racy).  
# A pattern rule, on the other hand, when it has multiple targets, is understood to produce all the outputs with a single run.
# What a hack...

#$(BLD)/generated_constants.h $(BLD)/generated_constants.cc: $(BLD)/objsizes
#	./$< $(BLD)/generated_constants.cc > $(BLD)/generated_constants.h

%/generated_constants.h %/generated_constants.cc: %/objsizes
	./$< $(patsubst %/objsizes, %/generated_constants.cc, $<) > $(patsubst %/objsizes, %/generated_constants.h, $<)

$(BLD)/objsizes: $(SRC)/objsizes.cc $(SRC)/malloc_internal.h
	$(CXX) $(CXXFLAGS) $< -o $@

%.pdf: %.gnuplot %.data
	gnuplot $<

clean:
	rm -f *.o $(TESTS) $(BLD)/objsizes $(BLD)/generated_constants.h $(BLD)/generated_constants.cc $(IMPLEMENTATION_FILES) 

